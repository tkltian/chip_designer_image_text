<!--
  Chip Designer - 2D + 3D Poker Chip Editor with Text

  Copyright (c) 2025 LT Innovations LLC
  GitHub: https://github.com/tkltian

  All rights reserved.
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>2D + 3D Chip Editor with Text</title>
<style>
body { font-family:sans-serif; background:#f5f5f5; display:flex; flex-direction:column; align-items:center; padding:20px; }
h1 { margin-bottom:20px; }
.chips-wrapper { display:flex; flex-wrap:wrap; justify-content:center; gap:40px; }
.chip-section { display:flex; flex-direction:column; align-items:center; }
.chip-title { font-weight:bold; margin-bottom:8px; }
.circle-container { position:relative; width:300px; height:300px; border-radius:50%; overflow:hidden; background-color:#eee; border:5px solid #bbb; box-shadow:0 4px 12px rgba(0,0,0,0.25); cursor:grab; touch-action:none; }
.circle-container:active { cursor:grabbing; }
.circle-image { position:absolute; top:50%; left:50%; transform-origin:center center; user-select:none; -webkit-user-drag:none; pointer-events:none; transform:translate(-50%,-50%) scale(1); }
.upload-input { margin-top:10px; }
.instructions { margin-top:10px; color:#666; font-size:14px; text-align:center; }
.download-btn { margin-top:15px; padding:8px 14px; background:#007bff; color:white; border:none; border-radius:4px; cursor:pointer; font-size:15px; }
.download-btn:disabled { background:#999; cursor:not-allowed; }
.download-btn:hover:not(:disabled) { background:#0056cc; }
#generate3d-btn { margin-top:40px; padding:10px 18px; font-size:16px; background:#28a745; border:none; color:white; border-radius:5px; cursor:pointer; }
#generate3d-btn:hover { background:#1f8a39; }
.color-selector { margin-top:10px; font-size:14px; }
#three-container { margin-top:40px; width:400px; height:400px; display:none; border:1px solid #ccc; }
#debug-canvases { display:flex; gap:10px; margin-top:20px; }
#debug-canvases img { border:1px solid #ccc; }
.text-editor { margin-top:10px; display:flex; flex-direction:column; gap:8px; align-items:center; }
.text-editor-row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:center; }
.text-editor input, .text-editor select { font-size:14px; padding:5px; }
.text-editor textarea { font-size:14px; padding:6px; resize:vertical; font-family:sans-serif; width:100%; max-width:280px; }
.text-editor label { display:flex; align-items:center; gap:5px; font-size:13px; }
.text-editor .range-control { display:flex; align-items:center; gap:5px; }
.text-editor .range-value { min-width:35px; font-size:12px; color:#666; }
.circle-canvas { position:absolute; top:0; left:0; width:100%; height:100%; user-select:none; pointer-events:none; }
.privacy-notice { max-width:700px; margin:0 auto 20px; padding:12px 20px; background:#e8f5e9; border-left:4px solid #4caf50; border-radius:4px; font-size:13px; color:#2e7d32; }
.privacy-notice strong { color:#1b5e20; }
.casino-values { margin-top:10px; display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }
.casino-value-btn { padding:8px 16px; background:#f0f0f0; border:2px solid #ddd; border-radius:4px; cursor:pointer; font-weight:bold; transition:all 0.2s; }
.casino-value-btn:hover { background:#e0e0e0; transform:scale(1.05); }
.casino-value-btn.active { background:#4caf50; color:white; border-color:#4caf50; }
</style>
</head>
<body>

<h1>LT Innovations Shop</h1>
<h2 style="margin-top:-10px; margin-bottom:20px; font-size:18px; color:#666; font-weight:normal;">2D + 3D Chip Design Preview</h2>

<div class="privacy-notice">
  <strong>üîí Privacy & Security:</strong> This is a static website that runs entirely in your browser. All images and designs you upload are processed locally on your device. No data is uploaded, shared, or stored on any server. Your privacy is fully protected.
</div>

<div class="chips-wrapper">
  <div class="chip-section" id="front-chip">
    <div class="chip-title">Front Side</div>
    <div class="circle-container"><img class="circle-image" src=""></div>
    <input type="file" class="upload-input" accept="image/*">
    <p class="instructions">üí° Drag image/text | Scroll to zoom image | Use controls below to customize text</p>
    <button class="download-btn" disabled>Download Front</button>
    <p style="margin-top:6px; font-size:12px; color:#666; font-style:italic; max-width:300px;">
      Download high-resolution image to send via Etsy chat. Thank you!
    </p>
    <div class="text-editor">
      <textarea class="text-input" placeholder="Enter text (multiple lines supported)" rows="2"></textarea>
      <div class="text-editor-row">
        <select class="font-select">
          <option value="Arial">Arial</option>
          <option value="Verdana">Verdana</option>
          <option value="Times New Roman">Times New Roman</option>
          <option value="Courier New">Courier New</option>
          <option value="Georgia">Georgia</option>
          <option value="Impact">Impact</option>
          <option value="Comic Sans MS">Comic Sans MS</option>
          <option value="Trebuchet MS">Trebuchet MS</option>
          <option value="Palatino">Palatino</option>
          <option value="Garamond">Garamond</option>
          <option value="Bookman">Bookman</option>
          <option value="Tahoma">Tahoma</option>
          <option value="Lucida Console">Lucida Console</option>
        </select>
        <select class="text-mode">
          <option value="straight">Straight</option>
          <option value="curved-upper">Curved Upper</option>
          <option value="curved-lower">Curved Lower</option>
        </select>
        <label>Color: <input type="color" class="text-color" value="#000000"></label>
      </div>
      <div class="text-editor-row">
        <div class="range-control">
          <label>Size:</label>
          <input type="range" class="text-size" min="12" max="72" value="24" step="1">
          <span class="range-value text-size-value">24px</span>
        </div>
        <div class="range-control">
          <label>Spacing:</label>
          <input type="range" class="char-spacing" min="-0.5" max="2" value="0" step="0.1">
          <span class="range-value char-spacing-value">0</span>
        </div>
      </div>
      <div class="text-editor-row">
        <select class="text-effect">
          <option value="none">No Effect</option>
          <option value="shadow">Drop Shadow</option>
          <option value="emboss">Embossed</option>
          <option value="outline">Bold Outline</option>
          <option value="glow">Glow</option>
        </select>
      </div>
    </div>

    <div class="bg-removal-section" style="margin-top:15px; padding:10px; background:#f9f9f9; border-radius:4px; border:1px solid #ddd;">
      <div style="font-weight:bold; font-size:13px; margin-bottom:5px;">üé® Remove Background (Optional)</div>
      <div style="font-size:11px; color:#666; margin-bottom:8px; line-height:1.4;">
        Remove solid-colored backgrounds (like white) from your image. Pick the background color and adjust tolerance to remove similar shades.
      </div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <label style="font-size:12px;">
          Color: <input type="color" class="bg-color-picker" value="#ffffff" style="width:40px; height:25px; cursor:pointer;">
        </label>
        <label style="font-size:12px; display:flex; align-items:center; gap:5px;">
          Tolerance: <input type="range" class="bg-tolerance" min="0" max="100" value="30" style="width:80px;">
          <span class="bg-tolerance-value" style="font-weight:bold;">30</span>
        </label>
        <button class="remove-bg-btn" style="padding:5px 10px; background:#ff6b6b; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;" disabled>Remove BG</button>
        <button class="undo-bg-btn" style="padding:5px 10px; background:#6c757d; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px; display:none;">Undo</button>
      </div>
    </div>
  </div>

  <div class="chip-section" id="back-chip">
    <div class="chip-title">Back Side</div>
    <div class="circle-container"><img class="circle-image" src=""></div>
    <input type="file" class="upload-input" accept="image/*">
    <div class="casino-values">
      <small style="width:100%; text-align:center; color:#666; margin-bottom:-4px;">Or use generic casino chip value:</small>
      <button class="casino-value-btn" data-value="1">1</button>
      <button class="casino-value-btn" data-value="5">5</button>
      <button class="casino-value-btn" data-value="10">10</button>
      <button class="casino-value-btn" data-value="25">25</button>
      <button class="casino-value-btn" data-value="100">100</button>
    </div>
    <p class="instructions">üí° Drag image/text | Scroll to zoom image | Use controls below to customize text</p>
    <button class="download-btn" disabled>Download Back</button>
    <p style="margin-top:6px; font-size:12px; color:#666; font-style:italic; max-width:300px;">
      Download high-resolution image to send via Etsy chat. Thank you!
    </p>
    <div class="text-editor">
      <textarea class="text-input" placeholder="Enter text (multiple lines supported)" rows="2"></textarea>
      <div class="text-editor-row">
        <select class="font-select">
          <option value="Arial">Arial</option>
          <option value="Verdana">Verdana</option>
          <option value="Times New Roman">Times New Roman</option>
          <option value="Courier New">Courier New</option>
          <option value="Georgia">Georgia</option>
          <option value="Impact">Impact</option>
          <option value="Comic Sans MS">Comic Sans MS</option>
          <option value="Trebuchet MS">Trebuchet MS</option>
          <option value="Palatino">Palatino</option>
          <option value="Garamond">Garamond</option>
          <option value="Bookman">Bookman</option>
          <option value="Tahoma">Tahoma</option>
          <option value="Lucida Console">Lucida Console</option>
        </select>
        <select class="text-mode">
          <option value="straight">Straight</option>
          <option value="curved-upper">Curved Upper</option>
          <option value="curved-lower">Curved Lower</option>
        </select>
        <label>Color: <input type="color" class="text-color" value="#000000"></label>
      </div>
      <div class="text-editor-row">
        <div class="range-control">
          <label>Size:</label>
          <input type="range" class="text-size" min="12" max="72" value="24" step="1">
          <span class="range-value text-size-value">24px</span>
        </div>
        <div class="range-control">
          <label>Spacing:</label>
          <input type="range" class="char-spacing" min="-0.5" max="2" value="0" step="0.1">
          <span class="range-value char-spacing-value">0</span>
        </div>
      </div>
      <div class="text-editor-row">
        <select class="text-effect">
          <option value="none">No Effect</option>
          <option value="shadow">Drop Shadow</option>
          <option value="emboss">Embossed</option>
          <option value="outline">Bold Outline</option>
          <option value="glow">Glow</option>
        </select>
      </div>
    </div>

    <div class="bg-removal-section" style="margin-top:15px; padding:10px; background:#f9f9f9; border-radius:4px; border:1px solid #ddd;">
      <div style="font-weight:bold; font-size:13px; margin-bottom:5px;">üé® Remove Background (Optional)</div>
      <div style="font-size:11px; color:#666; margin-bottom:8px; line-height:1.4;">
        Remove solid-colored backgrounds (like white) from your image. Pick the background color and adjust tolerance to remove similar shades.
      </div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <label style="font-size:12px;">
          Color: <input type="color" class="bg-color-picker" value="#ffffff" style="width:40px; height:25px; cursor:pointer;">
        </label>
        <label style="font-size:12px; display:flex; align-items:center; gap:5px;">
          Tolerance: <input type="range" class="bg-tolerance" min="0" max="100" value="30" style="width:80px;">
          <span class="bg-tolerance-value" style="font-weight:bold;">30</span>
        </label>
        <button class="remove-bg-btn" style="padding:5px 10px; background:#ff6b6b; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;" disabled>Remove BG</button>
        <button class="undo-bg-btn" style="padding:5px 10px; background:#6c757d; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px; display:none;">Undo</button>
      </div>
    </div>
  </div>
</div>

<button id="generate3d-btn">‚ú® Generate 3D Preview</button>
<p style="margin-top:8px; font-size:13px; color:#666; max-width:500px; text-align:center; font-style:italic;">
  The 3D preview is for reference only; the actual effect will depend on which chip style you choose, and what color that chip style is available with.
</p>

<div id="three-container"></div>

<div id="debug-canvases">
  <div>
    <div>Front canvas:</div>
    <img id="debug-front" width="100" height="100">
  </div>
  <div>
    <div>Back canvas:</div>
    <img id="debug-back" width="100" height="100">
  </div>
</div>

<footer style="margin-top:50px; padding:20px; text-align:center; border-top:1px solid #ddd; color:#666; font-size:13px;">
  <p style="margin:0;">Copyright &copy; 2025 LT Innovations LLC. All rights reserved.</p>
  <p style="margin:5px 0 0 0;">
    <a href="https://github.com/tkltian" target="_blank" style="color:#007bff; text-decoration:none;">GitHub</a>
  </p>
</footer>

<script>
function setupChipEditor(section) {
  const container = section.querySelector('.circle-container');
  const image = section.querySelector('.circle-image');
  const input = section.querySelector('.upload-input');
  const downloadBtn = section.querySelector('.download-btn');
  const textInput = section.querySelector('.text-input');
  const fontSelect = section.querySelector('.font-select');
  const textModeSelect = section.querySelector('.text-mode');
  const textColorInput = section.querySelector('.text-color');
  const textSizeInput = section.querySelector('.text-size');
  const textSizeValue = section.querySelector('.text-size-value');
  const charSpacingInput = section.querySelector('.char-spacing');
  const charSpacingValue = section.querySelector('.char-spacing-value');
  const textEffectSelect = section.querySelector('.text-effect');

  // Create and append canvas for displaying the composite
  const canvas = document.createElement('canvas');
  canvas.className = 'circle-canvas';
  canvas.width = 300;
  canvas.height = 300;
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d', { alpha: true }); // Enable alpha channel for transparency

  let scale = 1, offset={x:0,y:0}, dragging=false, start={x:0,y:0};
  let originalImage = new Image();
  let textBox={x:0,y:0,dragging:false,startX:0,startY:0,hovering:false};
  let lastTouchDist=0;

  input.addEventListener('change', e=>{
    const file = e.target.files[0]; if(!file) return;
    const reader = new FileReader();
    reader.onload = ()=>{
      originalImage.src = reader.result;
      image.src = reader.result;
      originalImage.onload = ()=>{
        scale=1;
        offset={x:0,y:0};
        updateTransform();
        drawCanvas();
        downloadBtn.disabled=false;
        // Enable background removal button
        const removeBgBtn = section.querySelector('.remove-bg-btn');
        if(removeBgBtn) removeBgBtn.disabled = false;
      }
    };
    reader.readAsDataURL(file);
  });

  // Background removal functionality
  const bgColorPicker = section.querySelector('.bg-color-picker');
  const bgTolerance = section.querySelector('.bg-tolerance');
  const bgToleranceValue = section.querySelector('.bg-tolerance-value');
  const removeBgBtn = section.querySelector('.remove-bg-btn');
  const undoBgBtn = section.querySelector('.undo-bg-btn');

  // Store original image before background removal
  let imageBeforeRemoval = null;

  if(bgTolerance && bgToleranceValue) {
    bgTolerance.addEventListener('input', ()=>{
      bgToleranceValue.textContent = bgTolerance.value;
    });
  }

  if(removeBgBtn) {
    removeBgBtn.addEventListener('click', ()=>{
      if(!originalImage.src) return;

      // Save current image for undo
      imageBeforeRemoval = originalImage.src;

      // Get the selected color
      const hexColor = bgColorPicker.value;
      const r = parseInt(hexColor.slice(1,3), 16);
      const g = parseInt(hexColor.slice(3,5), 16);
      const b = parseInt(hexColor.slice(5,7), 16);
      const tolerance = parseInt(bgTolerance.value);

      // Create a temporary canvas to process the image
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = originalImage.width;
      tempCanvas.height = originalImage.height;
      const tempCtx = tempCanvas.getContext('2d');

      // Draw the original image
      tempCtx.drawImage(originalImage, 0, 0);

      // Get image data
      const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
      const data = imageData.data;

      // Remove background pixels that match the selected color within tolerance
      for(let i = 0; i < data.length; i += 4) {
        const pr = data[i];
        const pg = data[i+1];
        const pb = data[i+2];

        // Calculate color difference
        const diff = Math.sqrt(
          Math.pow(pr - r, 2) +
          Math.pow(pg - g, 2) +
          Math.pow(pb - b, 2)
        );

        // If within tolerance, make transparent
        if(diff <= tolerance * 4.41) { // 4.41 scales tolerance 0-100 to 0-441 (max RGB distance)
          data[i+3] = 0; // Set alpha to 0
        }
      }

      // Put the modified image data back
      tempCtx.putImageData(imageData, 0, 0);

      // Update the image source with the processed image
      const processedDataURL = tempCanvas.toDataURL('image/png');
      originalImage.src = processedDataURL;
      image.src = processedDataURL;

      // Redraw
      originalImage.onload = ()=>{
        drawCanvas();
        console.log('‚úÖ Background removed');
        // Show undo button
        if(undoBgBtn) undoBgBtn.style.display = 'inline-block';
      };
    });
  }

  // Undo button functionality
  if(undoBgBtn) {
    undoBgBtn.addEventListener('click', ()=>{
      if(!imageBeforeRemoval) return;

      // Restore the image before background removal
      originalImage.src = imageBeforeRemoval;
      image.src = imageBeforeRemoval;

      // Redraw
      originalImage.onload = ()=>{
        drawCanvas();
        console.log('‚úÖ Background removal undone');
        // Hide undo button
        undoBgBtn.style.display = 'none';
        imageBeforeRemoval = null;
      };
    });
  }

  function isOverText(mx, my) {
    const textValue = textInput.value;
    if(!textValue) return false;

    if(textModeSelect.value === "straight") {
      // Bounding box check for straight text (multi-line aware)
      const fontSize = parseInt(textSizeInput.value);
      const lines = textValue.split('\n');
      const lineHeight = fontSize * 1.2;
      const totalHeight = lines.length * lineHeight;

      // Approximate width based on longest line
      const maxLineLength = Math.max(...lines.map(l => l.length));
      const approxWidth = maxLineLength * fontSize * 0.6;

      return Math.abs(mx - textBox.x) < approxWidth/2 + 20 &&
             Math.abs(my - textBox.y) < totalHeight/2 + 10;
    } else if(textModeSelect.value === "curved-upper") {
      // For curved upper text, check if in top circular region
      const dist = Math.sqrt(mx*mx + my*my);
      return dist < 100 && my < 0; // within top region
    } else if(textModeSelect.value === "curved-lower") {
      // For curved lower text, check if in bottom circular region
      const dist = Math.sqrt(mx*mx + my*my);
      return dist < 100 && my > 0; // within bottom region
    }
    return false;
  }

  container.addEventListener('mousedown', e=>{
    const rect = container.getBoundingClientRect();
    const mx=e.clientX-rect.left-150, my=e.clientY-rect.top-150;

    if(isOverText(mx, my)){
      textBox.dragging=true; textBox.startX=mx-textBox.x; textBox.startY=my-textBox.y;
    } else {
      dragging=true; start={x:e.clientX-offset.x,y:e.clientY-offset.y};
    }
  });

  container.addEventListener('mousemove', e=>{
    const rect = container.getBoundingClientRect();
    const mx=e.clientX-rect.left-150, my=e.clientY-rect.top-150;

    // Update hover state
    const wasHovering = textBox.hovering;
    textBox.hovering = isOverText(mx, my);
    container.style.cursor = textBox.hovering ? 'move' : 'grab';

    if(textBox.dragging){
      textBox.x=mx-textBox.startX; textBox.y=my-textBox.startY; drawCanvas();
    }
    else if(dragging){
      offset.x=e.clientX-start.x; offset.y=e.clientY-start.y; updateTransform(); drawCanvas();
    }
    else if(wasHovering !== textBox.hovering) {
      drawCanvas(); // Redraw to show/hide bounding box
    }
  });

  window.addEventListener('mouseup', ()=>{ dragging=false; textBox.dragging=false; });

  container.addEventListener('wheel', e=>{
    e.preventDefault();
    // Scroll to zoom image
    const rect=container.getBoundingClientRect();
    const cx=e.clientX-rect.left-150, cy=e.clientY-rect.top-150;
    const newScale=Math.min(Math.max(0.05,scale*(1-e.deltaY*0.002)),5);
    offset.x-=cx*(newScale/scale-1); offset.y-=cy*(newScale/scale-1);
    scale=newScale;
    updateTransform();
    drawCanvas();
  });

  // Touch support
  container.addEventListener('touchstart', e=>{
    if(e.touches.length===1){
      const rect = container.getBoundingClientRect();
      const mx=e.touches[0].clientX-rect.left-150, my=e.touches[0].clientY-rect.top-150;
      if(isOverText(mx, my)){
        textBox.dragging=true; textBox.startX=mx-textBox.x; textBox.startY=my-textBox.y;
      } else {
        dragging=true; start={x:e.touches[0].clientX-offset.x, y:e.touches[0].clientY-offset.y};
      }
    }
    else if(e.touches.length===2){
      dragging=false; textBox.dragging=false;
      lastTouchDist=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY);
    }
  });

  container.addEventListener('touchmove', e=>{
    e.preventDefault();
    if(e.touches.length===1){
      const rect = container.getBoundingClientRect();
      const mx=e.touches[0].clientX-rect.left-150, my=e.touches[0].clientY-rect.top-150;
      if(textBox.dragging){
        textBox.x=mx-textBox.startX; textBox.y=my-textBox.startY; drawCanvas();
      } else if(dragging){
        offset.x=e.touches[0].clientX-start.x; offset.y=e.touches[0].clientY-start.y; updateTransform(); drawCanvas();
      }
    }
    else if(e.touches.length===2){
      const newDist=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY);
      const zoomFactor=newDist/lastTouchDist;
      scale=Math.min(Math.max(0.05, scale*zoomFactor),5);
      lastTouchDist=newDist;
      updateTransform();
      drawCanvas();
    }
  });

  container.addEventListener('touchend', ()=>{ dragging=false; textBox.dragging=false; });

  textInput.addEventListener('input', drawCanvas);
  fontSelect.addEventListener('change', drawCanvas);
  textModeSelect.addEventListener('change', drawCanvas);
  textColorInput.addEventListener('input', drawCanvas);
  textSizeInput.addEventListener('input', ()=>{
    textSizeValue.textContent = textSizeInput.value + 'px';
    drawCanvas();
  });
  charSpacingInput.addEventListener('input', ()=>{
    charSpacingValue.textContent = charSpacingInput.value;
    drawCanvas();
  });
  textEffectSelect.addEventListener('change', drawCanvas);

  function updateTransform(){
    image.style.transform=`translate(calc(-50% + ${offset.x}px), calc(-50% + ${offset.y}px)) scale(${scale})`;
  }

  function drawTextWithEffect(text, x, y){
    const effect = textEffectSelect.value;
    const fontSize = parseInt(textSizeInput.value);
    const textColor = textColorInput.value;

    if(effect === 'shadow'){
      // Drop shadow effect
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillText(text, x+3, y+3);
      ctx.restore();
      ctx.strokeStyle = "white";
      ctx.lineWidth = Math.max(2, fontSize/12);
      ctx.strokeText(text, x, y);
      ctx.fillStyle = textColor;
      ctx.fillText(text, x, y);
    }
    else if(effect === 'emboss'){
      // Embossed 3D effect
      ctx.save();
      // Dark shadow (bottom right)
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.fillText(text, x+2, y+2);
      // Light highlight (top left)
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.fillText(text, x-1, y-1);
      ctx.restore();
      // Main text
      ctx.fillStyle = textColor;
      ctx.fillText(text, x, y);
    }
    else if(effect === 'outline'){
      // Bold outline effect
      ctx.strokeStyle = "black";
      ctx.lineWidth = Math.max(4, fontSize/6);
      ctx.strokeText(text, x, y);
      ctx.fillStyle = textColor;
      ctx.fillText(text, x, y);
    }
    else if(effect === 'glow'){
      // Glow effect
      ctx.save();
      ctx.shadowColor = textColor;
      ctx.shadowBlur = fontSize/3;
      ctx.fillStyle = textColor;
      ctx.fillText(text, x, y);
      ctx.shadowBlur = fontSize/2;
      ctx.fillText(text, x, y);
      ctx.restore();
      // Add white stroke
      ctx.strokeStyle = "white";
      ctx.lineWidth = Math.max(2, fontSize/12);
      ctx.strokeText(text, x, y);
      ctx.fillStyle = textColor;
      ctx.fillText(text, x, y);
    }
    else {
      // No effect - original white stroke + color fill
      ctx.strokeStyle = "white";
      ctx.lineWidth = Math.max(2, fontSize/12);
      ctx.strokeText(text, x, y);
      ctx.fillStyle = textColor;
      ctx.fillText(text, x, y);
    }
  }

  function drawCanvas(){
    const size=300;
    // Clear entire canvas to transparent
    ctx.clearRect(0,0,size,size);

    ctx.save();
    // Clip to circular region
    ctx.beginPath();
    ctx.arc(size/2,size/2,size/2,0,Math.PI*2);
    ctx.closePath();
    ctx.clip();

    if(originalImage.src){
      const iw=originalImage.width, ih=originalImage.height;
      ctx.drawImage(originalImage,(size-iw*scale)/2+offset.x,(size-ih*scale)/2+offset.y,iw*scale,ih*scale);
    }

    const textValue=textInput.value;
    if(textValue){
      const fontFamily=fontSelect.value;
      const fontSize=parseInt(textSizeInput.value);
      const textColor=textColorInput.value;
      ctx.fillStyle=textColor;
      ctx.strokeStyle="white";
      ctx.lineWidth=Math.max(2, fontSize/12);
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.font=`bold ${fontSize}px ${fontFamily}`;

      if(textModeSelect.value==="straight"){
        const tx = size/2+textBox.x;
        const ty = size/2+textBox.y;

        // Split text into lines
        const lines = textValue.split('\n');
        const lineHeight = fontSize * 1.2; // 1.2x line spacing
        const totalHeight = lines.length * lineHeight;
        const charSpacing = parseFloat(charSpacingInput.value);

        // Calculate max width for bounding box (with spacing)
        let maxWidth = 0;
        lines.forEach(line => {
          let lineWidth = 0;
          for(let i=0; i<line.length; i++){
            lineWidth += ctx.measureText(line[i]).width;
            if(i < line.length - 1) lineWidth += fontSize * charSpacing;
          }
          if(lineWidth > maxWidth) maxWidth = lineWidth;
        });

        // Draw bounding box when hovering
        if(textBox.hovering && !textBox.dragging){
          const boxWidth = maxWidth + 20;
          const boxHeight = totalHeight + 10;
          ctx.save();
          ctx.strokeStyle="rgba(0, 123, 255, 0.5)";
          ctx.lineWidth=2;
          ctx.setLineDash([5, 5]);
          ctx.strokeRect(tx-boxWidth/2, ty-boxHeight/2, boxWidth, boxHeight);
          ctx.restore();
        }

        // Draw each line centered with custom character spacing
        lines.forEach((line, index) => {
          const lineY = ty - totalHeight/2 + (index + 0.5) * lineHeight;

          // Calculate line width with spacing
          let lineWidth = 0;
          for(let i=0; i<line.length; i++){
            lineWidth += ctx.measureText(line[i]).width;
            if(i < line.length - 1) lineWidth += fontSize * charSpacing;
          }

          // Draw each character with spacing
          let currentX = tx - lineWidth/2;
          for(let i=0; i<line.length; i++){
            const char = line[i];
            const charWidth = ctx.measureText(char).width;
            drawTextWithEffect(char, currentX + charWidth/2, lineY);
            currentX += charWidth + (i < line.length - 1 ? fontSize * charSpacing : 0);
          }
        });
      }
      else if(textModeSelect.value==="curved-upper"){
        const radius=size/2-40;

        // Calculate total arc length needed based on character widths
        const charSpacing = parseFloat(charSpacingInput.value);
        let totalArcLength = 0;
        for(let i=0; i<textValue.length; i++){
          const charWidth = ctx.measureText(textValue[i]).width;
          totalArcLength += charWidth;
        }

        // Add spacing between characters (adjustable)
        totalArcLength += (textValue.length - 1) * fontSize * charSpacing;

        // Calculate angle needed for this arc length
        // arc length = radius √ó angle, so angle = arc length / radius
        let totalAngle = totalArcLength / radius;

        // Cap at 270 degrees (3œÄ/2) to prevent wrapping too far
        totalAngle = Math.min(totalAngle, Math.PI * 1.5);

        const startAngle = -Math.PI/2 - totalAngle/2; // Center on top

        // Draw arc guide when hovering
        if(textBox.hovering && !textBox.dragging){
          ctx.save();
          ctx.strokeStyle="rgba(0, 123, 255, 0.5)";
          ctx.lineWidth=2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.arc(size/2, size/2, radius, startAngle, startAngle + totalAngle);
          ctx.stroke();
          ctx.restore();
        }

        // Position each character based on its actual width
        let currentAngle = startAngle;
        for(let i=0; i<textValue.length; i++){
          const char = textValue[i];
          const charWidth = ctx.measureText(char).width;
          const charAngle = charWidth / radius;

          // Place character at center of its allocated arc
          const angle = currentAngle + charAngle/2;

          ctx.save();
          ctx.translate(size/2+radius*Math.cos(angle),size/2+radius*Math.sin(angle));
          ctx.rotate(angle+Math.PI/2);
          drawTextWithEffect(char,0,0);
          ctx.restore();

          // Move to next character position (char width + spacing)
          currentAngle += charAngle + (fontSize * charSpacing) / radius;
        }
      }
      else if(textModeSelect.value==="curved-lower"){
        const radius=size/2-40;

        // Calculate total arc length needed based on character widths
        const charSpacing = parseFloat(charSpacingInput.value);
        let totalArcLength = 0;
        for(let i=0; i<textValue.length; i++){
          const charWidth = ctx.measureText(textValue[i]).width;
          totalArcLength += charWidth;
        }

        // Add spacing between characters (adjustable)
        totalArcLength += (textValue.length - 1) * fontSize * charSpacing;

        // Calculate angle needed for this arc length
        // arc length = radius √ó angle, so angle = arc length / radius
        let totalAngle = totalArcLength / radius;

        // Cap at 270 degrees (3œÄ/2) to prevent wrapping too far
        totalAngle = Math.min(totalAngle, Math.PI * 1.5);

        // Center on bottom: start from RIGHT edge of the arc (for readable text)
        const centerAngle = Math.PI/2; // Bottom center (90 degrees)
        const startAngle = centerAngle + totalAngle/2; // Right edge of bottom arc

        // Draw arc guide when hovering
        if(textBox.hovering && !textBox.dragging){
          ctx.save();
          ctx.strokeStyle="rgba(0, 123, 255, 0.5)";
          ctx.lineWidth=2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.arc(size/2, size/2, radius, startAngle - totalAngle, startAngle);
          ctx.stroke();
          ctx.restore();
        }

        // Position each character based on its actual width (right to left for readability)
        let currentAngle = startAngle;
        for(let i=0; i<textValue.length; i++){
          const char = textValue[i];
          const charWidth = ctx.measureText(char).width;
          const charAngle = charWidth / radius;

          // Place character at center of its allocated arc
          const angle = currentAngle - charAngle/2;

          ctx.save();
          ctx.translate(size/2+radius*Math.cos(angle),size/2+radius*Math.sin(angle));
          ctx.rotate(angle-Math.PI/2); // Subtract PI/2 to keep characters upright (same as curved upper)
          drawTextWithEffect(char,0,0);
          ctx.restore();

          // Move to next character position (char width + spacing)
          currentAngle -= charAngle + (fontSize * charSpacing) / radius;
        }
      }
    }
    ctx.restore();
  }

  downloadBtn.addEventListener('click', ()=>{
    const dataURL = canvas.toDataURL('image/png');
    const link = document.createElement('a');
    link.download = `chip-${section.id}.png`;
    link.href = dataURL;
    link.click();
  });

  section.getCanvasDataURL = ()=>{
    if(!originalImage.src && !textInput.value) return null;
    return canvas.toDataURL('image/png');
  };

  // Expose a method to programmatically load an image
  section.loadImageFromDataURL = (dataURL)=>{
    originalImage.src = dataURL;
    image.src = dataURL;
    originalImage.onload = ()=>{
      scale=1;
      offset={x:0,y:0};
      updateTransform();
      drawCanvas();
      downloadBtn.disabled=false;
    }
  };
}

const frontSection=document.getElementById('front-chip');
const backSection=document.getElementById('back-chip');
setupChipEditor(frontSection);
setupChipEditor(backSection);

// Generate generic casino chip value images
function generateCasinoChipImage(value){
  const canvas = document.createElement('canvas');
  canvas.width = 600;
  canvas.height = 600;
  const ctx = canvas.getContext('2d');

  // Use artistic serif font with elegant styling
  // No background - transparent, just the number artistically rendered

  // Color scheme for text based on value (for visual variety)
  const colors = {
    1: '#1a1a1a',    // Dark gray
    5: '#8b0000',    // Dark red
    10: '#00008b',   // Dark blue
    25: '#006400',   // Dark green
    100: '#000000'   // Black
  };

  const textColor = colors[value] || '#1a1a1a';

  // Draw only one number in center with artistic font
  // Scale down font size for 100 to fit in circle
  const fontSize = value == 100 ? 150 : 180;

  ctx.fillStyle = textColor;
  ctx.font = `italic bold ${fontSize}px Georgia, serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Add subtle shadow for depth
  ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
  ctx.shadowBlur = 10;
  ctx.shadowOffsetX = 3;
  ctx.shadowOffsetY = 3;

  ctx.fillText(value, 300, 300);

  return canvas.toDataURL('image/png');
}

// Add event listeners for casino value buttons (back side only)
backSection.loadCasinoValue = function(value){
  const chipImageData = generateCasinoChipImage(value);

  // Use the exposed loadImageFromDataURL method
  this.loadImageFromDataURL(chipImageData);

  console.log(`‚úÖ Casino chip value $${value} loaded for back side`);
};

const backValueButtons = backSection.querySelectorAll('.casino-value-btn');
backValueButtons.forEach(btn => {
  btn.addEventListener('click', ()=>{
    const value = btn.getAttribute('data-value');
    backSection.loadCasinoValue(value);

    // Update button states
    backValueButtons.forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  });
});
</script>

<!-- 3D Preview JS -->
<script type="module">
  document.getElementById('generate3d-btn').addEventListener('click', async () => {
    console.log("üîπ Generate 3D Preview button clicked");

    const frontURL = frontSection.getCanvasDataURL();
    const backURL = backSection.getCanvasDataURL();

    // Debug canvases
    const debugFront = document.getElementById('debug-front');
    const debugBack = document.getElementById('debug-back');
    if(debugFront) debugFront.src = frontURL;
    if(debugBack) debugBack.src = backURL;
    console.log("üîπ Debug canvases updated for 3D preview");

    if(!frontURL || !backURL){
      alert("Please upload both front and back images");
      console.log("‚ùå Missing front or back image");
      return;
    }

    try{
      console.log("üîπ Loading Three.js modules...");
      const THREE = await import('https://cdn.skypack.dev/three@0.129.0/build/three.module.js');
      const { OrbitControls } = await import('https://cdn.skypack.dev/three@0.129.0/examples/jsm/controls/OrbitControls.js');
      const { GLTFLoader } = await import('https://cdn.skypack.dev/three@0.129.0/examples/jsm/loaders/GLTFLoader.js');
      console.log("‚úÖ Three.js, OrbitControls, and GLTFLoader loaded");

      const container3d = document.getElementById('three-container');
      container3d.style.display='block';
      container3d.innerHTML='';
      console.log("üîπ 3D container displayed");
  
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45,1,0.1,1000);
      camera.position.set(0,1.5,3);

      const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
      renderer.setSize(400,400);
      container3d.appendChild(renderer.domElement);
  
      // Controls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enablePan=false;
      controls.minDistance=2;
      controls.maxDistance=6;
  
      // Track user interaction
      let userIsInteracting = false;
      controls.addEventListener('start', ()=>{ userIsInteracting=true; });
      controls.addEventListener('end', ()=>{ userIsInteracting=false; });
      console.log("üîπ OrbitControls initialized with auto-rotate support");
  
      // Lighting
      const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
      dirLight.position.set(5,5,5);
      scene.add(dirLight);
  
      const ambLight = new THREE.AmbientLight(0xffffff,0.4);
      scene.add(ambLight);
  
      const hemiLight = new THREE.HemisphereLight(0xffffff,0x444444,0.3);
      scene.add(hemiLight);
      console.log("üîπ Lighting added");
  
      const loader = new THREE.TextureLoader();
      console.log("üîπ Loading front texture...");
      loader.load(frontURL, frontTex=>{
        console.log("‚úÖ Front texture loaded");
        loader.load(backURL, backTex=>{
          console.log("‚úÖ Back texture loaded");

          const frontMat = new THREE.MeshStandardMaterial({map:frontTex, metalness:0.2, roughness:0.4});
          const backMat = new THREE.MeshStandardMaterial({map:backTex, metalness:0.2, roughness:0.4});

          // Load GLB model
          const gltfLoader = new GLTFLoader();
          // Removed underscore prefix - GitHub Pages/Jekyll ignores files starting with _
          const modelPath = './chip_3d_model/model2.glb';
          console.log("üîπ Loading GLB from:", modelPath);
          gltfLoader.load(modelPath, (gltf)=>{
            console.log("‚úÖ GLB model loaded", gltf);
            const obj = gltf.scene;

            // Rotate the model so that its z-axis becomes the y-axis
            obj.rotation.x = Math.PI / 2;

            // Keep original materials from GLB, just enable shadows
            obj.traverse((child)=>{
              if(child.isMesh){
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });

            // Normalize the model size and position AFTER rotation
            const box = new THREE.Box3().setFromObject(obj);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            // Scale to fit approximately 2 units diameter
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 2 / maxDim;
            obj.scale.set(scale, scale, scale);

            // Recalculate after scaling
            const box2 = new THREE.Box3().setFromObject(obj);
            const center2 = box2.getCenter(new THREE.Vector3());
            obj.position.sub(center2);

            // Get the actual height of the chip after rotation and scaling
            const chipHeight = size.y * scale;

            // Create smaller circles for custom user images (center circle only)
            const innerCircleRadius = 0.57; // Adjusted to fill the embossed area
            const innerCircleGeom = new THREE.CircleGeometry(innerCircleRadius, 64);

            const frontCustomMesh = new THREE.Mesh(innerCircleGeom, frontMat);
            frontCustomMesh.position.y = chipHeight / 2 + 0.005; // On top of chip face
            frontCustomMesh.rotation.x = -Math.PI/2;

            const backCustomMesh = new THREE.Mesh(innerCircleGeom, backMat);
            backCustomMesh.position.y = -chipHeight / 2 - 0.005; // On top of chip face
            backCustomMesh.rotation.x = -Math.PI/2;
            backCustomMesh.rotation.y = Math.PI;

            // Group all parts
            const chipGroup = new THREE.Group();
            chipGroup.add(obj, frontCustomMesh, backCustomMesh);
            scene.add(chipGroup);
            console.log("‚úÖ Chip model added with custom images");

            // Set initial orientation: tilt slightly to show front face to user
            chipGroup.rotation.x = Math.PI * 0.15; // Tilt forward 27 degrees to show front
            chipGroup.rotation.y = 0;
            chipGroup.rotation.z = 0;

            // Animate with auto-rotation
            let rotationSpeed=0.005;
            function animate(){
              requestAnimationFrame(animate);
              if(!userIsInteracting){
                chipGroup.rotation.z += rotationSpeed;
              }
              renderer.render(scene,camera);
            }
            animate();
            console.log("‚úÖ Animation started with auto-rotation");

          }, undefined, err=>{
            console.error("‚ùå GLB model load error:",err);
            console.error("‚ùå Error details:", {
              message: err?.message,
              type: err?.constructor?.name,
              stack: err?.stack
            });
            alert("Failed to load 3D model. Check browser console for details.");
          });

        },undefined,err=>console.error("‚ùå Back texture load error:",err));
      },undefined,err=>console.error("‚ùå Front texture load error:",err));

    }catch(err){
      console.error("‚ùå Error initializing 3D preview:",err);
    }
  });
  </script>
  