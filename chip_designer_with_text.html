<!--
  Chip Designer - 2D + 3D Poker Chip Editor with Text

  Copyright (c) 2025 Lei (tkltian@gmail.com)
  GitHub: https://github.com/tkltian

  All rights reserved.
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>2D + 3D Chip Editor with Text</title>
<style>
body { font-family:sans-serif; background:#f5f5f5; display:flex; flex-direction:column; align-items:center; padding:20px; }
h1 { margin-bottom:20px; }
.chips-wrapper { display:flex; flex-wrap:wrap; justify-content:center; gap:40px; }
.chip-section { display:flex; flex-direction:column; align-items:center; }
.chip-title { font-weight:bold; margin-bottom:8px; }
.circle-container { position:relative; width:300px; height:300px; border-radius:50%; overflow:hidden; background-color:#eee; border:5px solid #bbb; box-shadow:0 4px 12px rgba(0,0,0,0.25); cursor:grab; touch-action:none; }
.circle-container:active { cursor:grabbing; }
.circle-image { position:absolute; top:50%; left:50%; transform-origin:center center; user-select:none; -webkit-user-drag:none; pointer-events:none; transform:translate(-50%,-50%) scale(1); }
.upload-input { margin-top:10px; }
.instructions { margin-top:10px; color:#666; font-size:14px; text-align:center; }
.download-btn { margin-top:15px; padding:8px 14px; background:#007bff; color:white; border:none; border-radius:4px; cursor:pointer; font-size:15px; }
.download-btn:disabled { background:#999; cursor:not-allowed; }
.download-btn:hover:not(:disabled) { background:#0056cc; }
#generate3d-btn { margin-top:40px; padding:10px 18px; font-size:16px; background:#28a745; border:none; color:white; border-radius:5px; cursor:pointer; }
#generate3d-btn:hover { background:#1f8a39; }
.color-selector { margin-top:10px; font-size:14px; }
#three-container { margin-top:40px; width:400px; height:400px; display:none; border:1px solid #ccc; }
#debug-canvases { display:flex; gap:10px; margin-top:20px; }
#debug-canvases img { border:1px solid #ccc; }
.text-editor { margin-top:10px; display:flex; flex-direction:column; gap:8px; align-items:center; }
.text-editor-row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:center; }
.text-editor input, .text-editor select { font-size:14px; padding:5px; }
.text-editor textarea { font-size:14px; padding:6px; resize:vertical; font-family:sans-serif; width:100%; max-width:280px; }
.text-editor label { display:flex; align-items:center; gap:5px; font-size:13px; }
.text-editor .range-control { display:flex; align-items:center; gap:5px; }
.text-editor .range-value { min-width:35px; font-size:12px; color:#666; }
.circle-canvas { position:absolute; top:0; left:0; width:100%; height:100%; user-select:none; pointer-events:none; }
.privacy-notice { max-width:700px; margin:0 auto 20px; padding:12px 20px; background:#e8f5e9; border-left:4px solid #4caf50; border-radius:4px; font-size:13px; color:#2e7d32; }
.privacy-notice strong { color:#1b5e20; }
</style>
</head>
<body>

<h1>LT Innovations Shop</h1>
<h2 style="margin-top:-10px; margin-bottom:20px; font-size:18px; color:#666; font-weight:normal;">2D + 3D Chip Design Preview</h2>

<div class="privacy-notice">
  <strong>üîí Privacy & Security:</strong> This is a static website that runs entirely in your browser. All images and designs you upload are processed locally on your device. No data is uploaded, shared, or stored on any server. Your privacy is fully protected.
</div>

<div class="chips-wrapper">
  <div class="chip-section" id="front-chip">
    <div class="chip-title">Front Side</div>
    <div class="circle-container"><img class="circle-image" src=""></div>
    <input type="file" class="upload-input" accept="image/*">
    <p class="instructions">üí° Drag image/text | Scroll to zoom image | Use controls below to customize text</p>
    <button class="download-btn" disabled>Download Front</button>
    <div class="text-editor">
      <textarea class="text-input" placeholder="Enter text (multiple lines supported)" rows="2"></textarea>
      <div class="text-editor-row">
        <select class="font-select">
          <option value="Arial">Arial</option>
          <option value="Verdana">Verdana</option>
          <option value="Times New Roman">Times New Roman</option>
          <option value="Courier New">Courier New</option>
          <option value="Georgia">Georgia</option>
          <option value="Impact">Impact</option>
          <option value="Comic Sans MS">Comic Sans MS</option>
          <option value="Trebuchet MS">Trebuchet MS</option>
          <option value="Palatino">Palatino</option>
          <option value="Garamond">Garamond</option>
          <option value="Bookman">Bookman</option>
          <option value="Tahoma">Tahoma</option>
          <option value="Lucida Console">Lucida Console</option>
        </select>
        <select class="text-mode">
          <option value="straight">Straight</option>
          <option value="curved-upper">Curved Upper</option>
          <option value="curved-lower">Curved Lower</option>
        </select>
        <label>Color: <input type="color" class="text-color" value="#000000"></label>
      </div>
      <div class="text-editor-row">
        <div class="range-control">
          <label>Size:</label>
          <input type="range" class="text-size" min="12" max="72" value="24" step="1">
          <span class="range-value text-size-value">24px</span>
        </div>
        <div class="range-control">
          <label>Spacing:</label>
          <input type="range" class="char-spacing" min="-0.5" max="2" value="0" step="0.1">
          <span class="range-value char-spacing-value">0</span>
        </div>
      </div>
      <div class="text-editor-row">
        <select class="text-effect">
          <option value="none">No Effect</option>
          <option value="shadow">Drop Shadow</option>
          <option value="emboss">Embossed</option>
          <option value="outline">Bold Outline</option>
          <option value="glow">Glow</option>
        </select>
      </div>
    </div>
  </div>

  <div class="chip-section" id="back-chip">
    <div class="chip-title">Back Side</div>
    <div class="circle-container"><img class="circle-image" src=""></div>
    <input type="file" class="upload-input" accept="image/*">
    <p class="instructions">üí° Drag image/text | Scroll to zoom image | Use controls below to customize text</p>
    <button class="download-btn" disabled>Download Back</button>
    <div class="text-editor">
      <textarea class="text-input" placeholder="Enter text (multiple lines supported)" rows="2"></textarea>
      <div class="text-editor-row">
        <select class="font-select">
          <option value="Arial">Arial</option>
          <option value="Verdana">Verdana</option>
          <option value="Times New Roman">Times New Roman</option>
          <option value="Courier New">Courier New</option>
          <option value="Georgia">Georgia</option>
          <option value="Impact">Impact</option>
          <option value="Comic Sans MS">Comic Sans MS</option>
          <option value="Trebuchet MS">Trebuchet MS</option>
          <option value="Palatino">Palatino</option>
          <option value="Garamond">Garamond</option>
          <option value="Bookman">Bookman</option>
          <option value="Tahoma">Tahoma</option>
          <option value="Lucida Console">Lucida Console</option>
        </select>
        <select class="text-mode">
          <option value="straight">Straight</option>
          <option value="curved-upper">Curved Upper</option>
          <option value="curved-lower">Curved Lower</option>
        </select>
        <label>Color: <input type="color" class="text-color" value="#000000"></label>
      </div>
      <div class="text-editor-row">
        <div class="range-control">
          <label>Size:</label>
          <input type="range" class="text-size" min="12" max="72" value="24" step="1">
          <span class="range-value text-size-value">24px</span>
        </div>
        <div class="range-control">
          <label>Spacing:</label>
          <input type="range" class="char-spacing" min="-0.5" max="2" value="0" step="0.1">
          <span class="range-value char-spacing-value">0</span>
        </div>
      </div>
      <div class="text-editor-row">
        <select class="text-effect">
          <option value="none">No Effect</option>
          <option value="shadow">Drop Shadow</option>
          <option value="emboss">Embossed</option>
          <option value="outline">Bold Outline</option>
          <option value="glow">Glow</option>
        </select>
      </div>
    </div>
  </div>
</div>

<button id="generate3d-btn">‚ú® Generate 3D Preview</button>
<p style="margin-top:8px; font-size:13px; color:#666; max-width:500px; text-align:center; font-style:italic;">
  The 3D preview is for reference only; the actual effect will depend on which chip style you choose, and what color that chip style is available with.
</p>

<div id="three-container"></div>

<div id="debug-canvases">
  <div>
    <div>Front canvas:</div>
    <img id="debug-front" width="100" height="100">
  </div>
  <div>
    <div>Back canvas:</div>
    <img id="debug-back" width="100" height="100">
  </div>
</div>

<script>
function setupChipEditor(section) {
  const container = section.querySelector('.circle-container');
  const image = section.querySelector('.circle-image');
  const input = section.querySelector('.upload-input');
  const downloadBtn = section.querySelector('.download-btn');
  const textInput = section.querySelector('.text-input');
  const fontSelect = section.querySelector('.font-select');
  const textModeSelect = section.querySelector('.text-mode');
  const textColorInput = section.querySelector('.text-color');
  const textSizeInput = section.querySelector('.text-size');
  const textSizeValue = section.querySelector('.text-size-value');
  const charSpacingInput = section.querySelector('.char-spacing');
  const charSpacingValue = section.querySelector('.char-spacing-value');
  const textEffectSelect = section.querySelector('.text-effect');

  // Create and append canvas for displaying the composite
  const canvas = document.createElement('canvas');
  canvas.className = 'circle-canvas';
  canvas.width = 300;
  canvas.height = 300;
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  let scale = 1, offset={x:0,y:0}, dragging=false, start={x:0,y:0};
  let originalImage = new Image();
  let textBox={x:0,y:0,dragging:false,startX:0,startY:0,hovering:false};
  let lastTouchDist=0;

  input.addEventListener('change', e=>{
    const file = e.target.files[0]; if(!file) return;
    const reader = new FileReader();
    reader.onload = ()=>{
      originalImage.src = reader.result;
      image.src = reader.result;
      originalImage.onload = ()=>{ scale=1; offset={x:0,y:0}; updateTransform(); drawCanvas(); downloadBtn.disabled=false; }
    };
    reader.readAsDataURL(file);
  });

  function isOverText(mx, my) {
    const textValue = textInput.value;
    if(!textValue) return false;

    if(textModeSelect.value === "straight") {
      // Bounding box check for straight text (multi-line aware)
      const fontSize = parseInt(textSizeInput.value);
      const lines = textValue.split('\n');
      const lineHeight = fontSize * 1.2;
      const totalHeight = lines.length * lineHeight;

      // Approximate width based on longest line
      const maxLineLength = Math.max(...lines.map(l => l.length));
      const approxWidth = maxLineLength * fontSize * 0.6;

      return Math.abs(mx - textBox.x) < approxWidth/2 + 20 &&
             Math.abs(my - textBox.y) < totalHeight/2 + 10;
    } else if(textModeSelect.value === "curved-upper") {
      // For curved upper text, check if in top circular region
      const dist = Math.sqrt(mx*mx + my*my);
      return dist < 100 && my < 0; // within top region
    } else if(textModeSelect.value === "curved-lower") {
      // For curved lower text, check if in bottom circular region
      const dist = Math.sqrt(mx*mx + my*my);
      return dist < 100 && my > 0; // within bottom region
    }
    return false;
  }

  container.addEventListener('mousedown', e=>{
    const rect = container.getBoundingClientRect();
    const mx=e.clientX-rect.left-150, my=e.clientY-rect.top-150;

    if(isOverText(mx, my)){
      textBox.dragging=true; textBox.startX=mx-textBox.x; textBox.startY=my-textBox.y;
    } else {
      dragging=true; start={x:e.clientX-offset.x,y:e.clientY-offset.y};
    }
  });

  container.addEventListener('mousemove', e=>{
    const rect = container.getBoundingClientRect();
    const mx=e.clientX-rect.left-150, my=e.clientY-rect.top-150;

    // Update hover state
    const wasHovering = textBox.hovering;
    textBox.hovering = isOverText(mx, my);
    container.style.cursor = textBox.hovering ? 'move' : 'grab';

    if(textBox.dragging){
      textBox.x=mx-textBox.startX; textBox.y=my-textBox.startY; drawCanvas();
    }
    else if(dragging){
      offset.x=e.clientX-start.x; offset.y=e.clientY-start.y; updateTransform(); drawCanvas();
    }
    else if(wasHovering !== textBox.hovering) {
      drawCanvas(); // Redraw to show/hide bounding box
    }
  });

  window.addEventListener('mouseup', ()=>{ dragging=false; textBox.dragging=false; });

  container.addEventListener('wheel', e=>{
    e.preventDefault();
    // Scroll to zoom image
    const rect=container.getBoundingClientRect();
    const cx=e.clientX-rect.left-150, cy=e.clientY-rect.top-150;
    const newScale=Math.min(Math.max(0.05,scale*(1-e.deltaY*0.002)),5);
    offset.x-=cx*(newScale/scale-1); offset.y-=cy*(newScale/scale-1);
    scale=newScale;
    updateTransform();
    drawCanvas();
  });

  // Touch support
  container.addEventListener('touchstart', e=>{
    if(e.touches.length===1){
      const rect = container.getBoundingClientRect();
      const mx=e.touches[0].clientX-rect.left-150, my=e.touches[0].clientY-rect.top-150;
      if(isOverText(mx, my)){
        textBox.dragging=true; textBox.startX=mx-textBox.x; textBox.startY=my-textBox.y;
      } else {
        dragging=true; start={x:e.touches[0].clientX-offset.x, y:e.touches[0].clientY-offset.y};
      }
    }
    else if(e.touches.length===2){
      dragging=false; textBox.dragging=false;
      lastTouchDist=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY);
    }
  });

  container.addEventListener('touchmove', e=>{
    e.preventDefault();
    if(e.touches.length===1){
      const rect = container.getBoundingClientRect();
      const mx=e.touches[0].clientX-rect.left-150, my=e.touches[0].clientY-rect.top-150;
      if(textBox.dragging){
        textBox.x=mx-textBox.startX; textBox.y=my-textBox.startY; drawCanvas();
      } else if(dragging){
        offset.x=e.touches[0].clientX-start.x; offset.y=e.touches[0].clientY-start.y; updateTransform(); drawCanvas();
      }
    }
    else if(e.touches.length===2){
      const newDist=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY);
      const zoomFactor=newDist/lastTouchDist;
      scale=Math.min(Math.max(0.05, scale*zoomFactor),5);
      lastTouchDist=newDist;
      updateTransform();
      drawCanvas();
    }
  });

  container.addEventListener('touchend', ()=>{ dragging=false; textBox.dragging=false; });

  textInput.addEventListener('input', drawCanvas);
  fontSelect.addEventListener('change', drawCanvas);
  textModeSelect.addEventListener('change', drawCanvas);
  textColorInput.addEventListener('input', drawCanvas);
  textSizeInput.addEventListener('input', ()=>{
    textSizeValue.textContent = textSizeInput.value + 'px';
    drawCanvas();
  });
  charSpacingInput.addEventListener('input', ()=>{
    charSpacingValue.textContent = charSpacingInput.value;
    drawCanvas();
  });
  textEffectSelect.addEventListener('change', drawCanvas);

  function updateTransform(){
    image.style.transform=`translate(calc(-50% + ${offset.x}px), calc(-50% + ${offset.y}px)) scale(${scale})`;
  }

  function drawTextWithEffect(text, x, y){
    const effect = textEffectSelect.value;
    const fontSize = parseInt(textSizeInput.value);
    const textColor = textColorInput.value;

    if(effect === 'shadow'){
      // Drop shadow effect
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillText(text, x+3, y+3);
      ctx.restore();
      ctx.strokeStyle = "white";
      ctx.lineWidth = Math.max(2, fontSize/12);
      ctx.strokeText(text, x, y);
      ctx.fillStyle = textColor;
      ctx.fillText(text, x, y);
    }
    else if(effect === 'emboss'){
      // Embossed 3D effect
      ctx.save();
      // Dark shadow (bottom right)
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.fillText(text, x+2, y+2);
      // Light highlight (top left)
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.fillText(text, x-1, y-1);
      ctx.restore();
      // Main text
      ctx.fillStyle = textColor;
      ctx.fillText(text, x, y);
    }
    else if(effect === 'outline'){
      // Bold outline effect
      ctx.strokeStyle = "black";
      ctx.lineWidth = Math.max(4, fontSize/6);
      ctx.strokeText(text, x, y);
      ctx.fillStyle = textColor;
      ctx.fillText(text, x, y);
    }
    else if(effect === 'glow'){
      // Glow effect
      ctx.save();
      ctx.shadowColor = textColor;
      ctx.shadowBlur = fontSize/3;
      ctx.fillStyle = textColor;
      ctx.fillText(text, x, y);
      ctx.shadowBlur = fontSize/2;
      ctx.fillText(text, x, y);
      ctx.restore();
      // Add white stroke
      ctx.strokeStyle = "white";
      ctx.lineWidth = Math.max(2, fontSize/12);
      ctx.strokeText(text, x, y);
      ctx.fillStyle = textColor;
      ctx.fillText(text, x, y);
    }
    else {
      // No effect - original white stroke + color fill
      ctx.strokeStyle = "white";
      ctx.lineWidth = Math.max(2, fontSize/12);
      ctx.strokeText(text, x, y);
      ctx.fillStyle = textColor;
      ctx.fillText(text, x, y);
    }
  }

  function drawCanvas(){
    const size=300;
    ctx.clearRect(0,0,size,size);
    ctx.save();
    ctx.beginPath();
    ctx.arc(size/2,size/2,size/2,0,Math.PI*2);
    ctx.closePath();
    ctx.clip();

    if(originalImage.src){
      const iw=originalImage.width, ih=originalImage.height;
      ctx.drawImage(originalImage,(size-iw*scale)/2+offset.x,(size-ih*scale)/2+offset.y,iw*scale,ih*scale);
    }

    const textValue=textInput.value;
    if(textValue){
      const fontFamily=fontSelect.value;
      const fontSize=parseInt(textSizeInput.value);
      const textColor=textColorInput.value;
      ctx.fillStyle=textColor;
      ctx.strokeStyle="white";
      ctx.lineWidth=Math.max(2, fontSize/12);
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.font=`bold ${fontSize}px ${fontFamily}`;

      if(textModeSelect.value==="straight"){
        const tx = size/2+textBox.x;
        const ty = size/2+textBox.y;

        // Split text into lines
        const lines = textValue.split('\n');
        const lineHeight = fontSize * 1.2; // 1.2x line spacing
        const totalHeight = lines.length * lineHeight;
        const charSpacing = parseFloat(charSpacingInput.value);

        // Calculate max width for bounding box (with spacing)
        let maxWidth = 0;
        lines.forEach(line => {
          let lineWidth = 0;
          for(let i=0; i<line.length; i++){
            lineWidth += ctx.measureText(line[i]).width;
            if(i < line.length - 1) lineWidth += fontSize * charSpacing;
          }
          if(lineWidth > maxWidth) maxWidth = lineWidth;
        });

        // Draw bounding box when hovering
        if(textBox.hovering && !textBox.dragging){
          const boxWidth = maxWidth + 20;
          const boxHeight = totalHeight + 10;
          ctx.save();
          ctx.strokeStyle="rgba(0, 123, 255, 0.5)";
          ctx.lineWidth=2;
          ctx.setLineDash([5, 5]);
          ctx.strokeRect(tx-boxWidth/2, ty-boxHeight/2, boxWidth, boxHeight);
          ctx.restore();
        }

        // Draw each line centered with custom character spacing
        lines.forEach((line, index) => {
          const lineY = ty - totalHeight/2 + (index + 0.5) * lineHeight;

          // Calculate line width with spacing
          let lineWidth = 0;
          for(let i=0; i<line.length; i++){
            lineWidth += ctx.measureText(line[i]).width;
            if(i < line.length - 1) lineWidth += fontSize * charSpacing;
          }

          // Draw each character with spacing
          let currentX = tx - lineWidth/2;
          for(let i=0; i<line.length; i++){
            const char = line[i];
            const charWidth = ctx.measureText(char).width;
            drawTextWithEffect(char, currentX + charWidth/2, lineY);
            currentX += charWidth + (i < line.length - 1 ? fontSize * charSpacing : 0);
          }
        });
      }
      else if(textModeSelect.value==="curved-upper"){
        const radius=size/2-40;

        // Calculate total arc length needed based on character widths
        const charSpacing = parseFloat(charSpacingInput.value);
        let totalArcLength = 0;
        for(let i=0; i<textValue.length; i++){
          const charWidth = ctx.measureText(textValue[i]).width;
          totalArcLength += charWidth;
        }

        // Add spacing between characters (adjustable)
        totalArcLength += (textValue.length - 1) * fontSize * charSpacing;

        // Calculate angle needed for this arc length
        // arc length = radius √ó angle, so angle = arc length / radius
        let totalAngle = totalArcLength / radius;

        // Cap at 270 degrees (3œÄ/2) to prevent wrapping too far
        totalAngle = Math.min(totalAngle, Math.PI * 1.5);

        const startAngle = -Math.PI/2 - totalAngle/2; // Center on top

        // Draw arc guide when hovering
        if(textBox.hovering && !textBox.dragging){
          ctx.save();
          ctx.strokeStyle="rgba(0, 123, 255, 0.5)";
          ctx.lineWidth=2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.arc(size/2, size/2, radius, startAngle, startAngle + totalAngle);
          ctx.stroke();
          ctx.restore();
        }

        // Position each character based on its actual width
        let currentAngle = startAngle;
        for(let i=0; i<textValue.length; i++){
          const char = textValue[i];
          const charWidth = ctx.measureText(char).width;
          const charAngle = charWidth / radius;

          // Place character at center of its allocated arc
          const angle = currentAngle + charAngle/2;

          ctx.save();
          ctx.translate(size/2+radius*Math.cos(angle),size/2+radius*Math.sin(angle));
          ctx.rotate(angle+Math.PI/2);
          drawTextWithEffect(char,0,0);
          ctx.restore();

          // Move to next character position (char width + spacing)
          currentAngle += charAngle + (fontSize * charSpacing) / radius;
        }
      }
      else if(textModeSelect.value==="curved-lower"){
        const radius=size/2-40;

        // Calculate total arc length needed based on character widths
        const charSpacing = parseFloat(charSpacingInput.value);
        let totalArcLength = 0;
        for(let i=0; i<textValue.length; i++){
          const charWidth = ctx.measureText(textValue[i]).width;
          totalArcLength += charWidth;
        }

        // Add spacing between characters (adjustable)
        totalArcLength += (textValue.length - 1) * fontSize * charSpacing;

        // Calculate angle needed for this arc length
        // arc length = radius √ó angle, so angle = arc length / radius
        let totalAngle = totalArcLength / radius;

        // Cap at 270 degrees (3œÄ/2) to prevent wrapping too far
        totalAngle = Math.min(totalAngle, Math.PI * 1.5);

        // Center on bottom: start from RIGHT edge of the arc (for readable text)
        const centerAngle = Math.PI/2; // Bottom center (90 degrees)
        const startAngle = centerAngle + totalAngle/2; // Right edge of bottom arc

        // Draw arc guide when hovering
        if(textBox.hovering && !textBox.dragging){
          ctx.save();
          ctx.strokeStyle="rgba(0, 123, 255, 0.5)";
          ctx.lineWidth=2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.arc(size/2, size/2, radius, startAngle - totalAngle, startAngle);
          ctx.stroke();
          ctx.restore();
        }

        // Position each character based on its actual width (right to left for readability)
        let currentAngle = startAngle;
        for(let i=0; i<textValue.length; i++){
          const char = textValue[i];
          const charWidth = ctx.measureText(char).width;
          const charAngle = charWidth / radius;

          // Place character at center of its allocated arc
          const angle = currentAngle - charAngle/2;

          ctx.save();
          ctx.translate(size/2+radius*Math.cos(angle),size/2+radius*Math.sin(angle));
          ctx.rotate(angle-Math.PI/2); // Subtract PI/2 to keep characters upright (same as curved upper)
          drawTextWithEffect(char,0,0);
          ctx.restore();

          // Move to next character position (char width + spacing)
          currentAngle -= charAngle + (fontSize * charSpacing) / radius;
        }
      }
    }
    ctx.restore();
  }

  downloadBtn.addEventListener('click', ()=>{
    const dataURL = canvas.toDataURL('image/png');
    const link = document.createElement('a');
    link.download = `chip-${section.id}.png`;
    link.href = dataURL;
    link.click();
  });

  section.getCanvasDataURL = ()=>{
    if(!originalImage.src && !textInput.value) return null;
    return canvas.toDataURL('image/png');
  };
}

const frontSection=document.getElementById('front-chip');
const backSection=document.getElementById('back-chip');
setupChipEditor(frontSection);
setupChipEditor(backSection);
</script>

<!-- 3D Preview JS -->
<script type="module">
  document.getElementById('generate3d-btn').addEventListener('click', async () => {
    console.log("üîπ Generate 3D Preview button clicked");
  
    const frontURL = frontSection.getCanvasDataURL();
    const backURL = backSection.getCanvasDataURL();
  
    // Debug canvases
    const debugFront = document.getElementById('debug-front');
    const debugBack = document.getElementById('debug-back');
    if(debugFront) debugFront.src = frontURL;
    if(debugBack) debugBack.src = backURL;
    console.log("üîπ Debug canvases updated for 3D preview");
  
    if(!frontURL || !backURL){
      alert("Please upload both front and back images");
      console.log("‚ùå Missing front or back image");
      return;
    }
  
    try{
      console.log("üîπ Loading Three.js modules...");
      const THREE = await import('https://cdn.skypack.dev/three@0.129.0/build/three.module.js');
      const { OrbitControls } = await import('https://cdn.skypack.dev/three@0.129.0/examples/jsm/controls/OrbitControls.js');
      const { GLTFLoader } = await import('https://cdn.skypack.dev/three@0.129.0/examples/jsm/loaders/GLTFLoader.js');
      console.log("‚úÖ Three.js, OrbitControls, and GLTFLoader loaded");
  
      const container3d = document.getElementById('three-container');
      container3d.style.display='block';
      container3d.innerHTML='';
      console.log("üîπ 3D container displayed");
  
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45,1,0.1,1000);
      camera.position.set(0,1.5,3);
  
      const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
      renderer.setSize(400,400);
      container3d.appendChild(renderer.domElement);
      console.log("üîπ Renderer created");
  
      // Controls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enablePan=false;
      controls.minDistance=2;
      controls.maxDistance=6;
  
      // Track user interaction
      let userIsInteracting = false;
      controls.addEventListener('start', ()=>{ userIsInteracting=true; });
      controls.addEventListener('end', ()=>{ userIsInteracting=false; });
      console.log("üîπ OrbitControls initialized with auto-rotate support");
  
      // Lighting
      const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
      dirLight.position.set(5,5,5);
      scene.add(dirLight);
  
      const ambLight = new THREE.AmbientLight(0xffffff,0.4);
      scene.add(ambLight);
  
      const hemiLight = new THREE.HemisphereLight(0xffffff,0x444444,0.3);
      scene.add(hemiLight);
      console.log("üîπ Lighting added");
  
      const loader = new THREE.TextureLoader();
      console.log("üîπ Loading front texture...");
      loader.load(frontURL, frontTex=>{
        console.log("‚úÖ Front texture loaded");
        loader.load(backURL, backTex=>{
          console.log("‚úÖ Back texture loaded");

          const frontMat = new THREE.MeshStandardMaterial({map:frontTex, metalness:0.2, roughness:0.4});
          const backMat = new THREE.MeshStandardMaterial({map:backTex, metalness:0.2, roughness:0.4});

          // Load GLB model
          const gltfLoader = new GLTFLoader();
          gltfLoader.load('chip_3d_model/_model2.glb', (gltf)=>{
            console.log("‚úÖ GLB model loaded", gltf);
            const obj = gltf.scene;

            // Rotate the model so that its z-axis becomes the y-axis
            obj.rotation.x = Math.PI / 2;

            // Keep original materials from GLB, just enable shadows
            obj.traverse((child)=>{
              if(child.isMesh){
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });

            // Normalize the model size and position AFTER rotation
            const box = new THREE.Box3().setFromObject(obj);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            // Scale to fit approximately 2 units diameter
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 2 / maxDim;
            obj.scale.set(scale, scale, scale);

            // Recalculate after scaling
            const box2 = new THREE.Box3().setFromObject(obj);
            const center2 = box2.getCenter(new THREE.Vector3());
            obj.position.sub(center2);

            // Get the actual height of the chip after rotation and scaling
            const chipHeight = size.y * scale;

            // Create smaller circles for custom user images (center circle only)
            const innerCircleRadius = 0.57; // Adjusted to fill the embossed area
            const innerCircleGeom = new THREE.CircleGeometry(innerCircleRadius, 64);

            const frontCustomMesh = new THREE.Mesh(innerCircleGeom, frontMat);
            frontCustomMesh.position.y = chipHeight / 2 + 0.005; // On top of chip face
            frontCustomMesh.rotation.x = -Math.PI/2;

            const backCustomMesh = new THREE.Mesh(innerCircleGeom, backMat);
            backCustomMesh.position.y = -chipHeight / 2 - 0.005; // On top of chip face
            backCustomMesh.rotation.x = -Math.PI/2;
            backCustomMesh.rotation.y = Math.PI;

            // Group all parts
            const chipGroup = new THREE.Group();
            chipGroup.add(obj, frontCustomMesh, backCustomMesh);
            scene.add(chipGroup);
            console.log("‚úÖ Chip model added with custom images");

            // Set initial orientation: tilt slightly to show front face to user
            chipGroup.rotation.x = Math.PI * 0.15; // Tilt forward 27 degrees to show front
            chipGroup.rotation.y = 0;
            chipGroup.rotation.z = 0;

            // Animate with auto-rotation
            let rotationSpeed=0.005;
            function animate(){
              requestAnimationFrame(animate);
              if(!userIsInteracting){
                chipGroup.rotation.z += rotationSpeed;
              }
              renderer.render(scene,camera);
            }
            animate();
            console.log("‚úÖ Animation started with auto-rotation");

          }, undefined, err=>console.error("‚ùå GLB model load error:",err));
  
        },undefined,err=>console.error("‚ùå Back texture load error:",err));
      },undefined,err=>console.error("‚ùå Front texture load error:",err));
  
    }catch(err){
      console.error("‚ùå Error initializing 3D preview:",err);
    }
  });
  </script>
  